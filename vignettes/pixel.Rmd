---
title: "tipixel"
author: "Vincent Guyader"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tipixel}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



`tipixel`  est un package qui permet de reconstruire une image au format jpeg à partir d'autres images miniaturisées. Le résultat est alors une mosaïque d'images qui représente l'image originelle. L'idée est de découper l'image originelle en plusieurs `pixel`, en quadrillant l'image, et d'ensuite remplacer chaque pixel par une autre image (appelée tuile) aux coloris proches.
Il est donc nécessaire d'avoir non seulement une image à transformer, mais aussi une base d'autres images qui seront utilisées pour reconstruire l'image originelle (`target`).

Mathématiquement, il s'agit de rechercher, pour chaque `pixel`, dans l'espace à 3 dimensions des couleurs primaires (R,V,B), le/les plus proches voisins dans la base d'images. Ce type de calcul peut rapidement se complexifier et devenir assez long, un important effort a été réalisé afin d'optimiser les temps de calcul - en permettant par exemple l'usage des différents coeurs de la machine.

À VENIR : _réaliser les calculs non plus in-memory mais directement sur le disque dur. L'objectif est de permettre aux ordinateurs dispoosant de trop peu de ram de générer de gros fichiers image_

(décrire les différentes étapes ? se constituer une base puis construire une nouvelle image à partir de cette dernière)

## Création d'une base d'image

La fonction `genere_base` permet de lire le contenu d'un dossier afin d'en constituer une base de tuiles. Elle incorpore les images au format jpeg et ne sélectionne que les fichiers .jpeg ou .jpg via un filtre sur l'extension. Le paramètre `redim` permet de définir la dimension (hauteur x largeur) des tuiles, c'est l'un des critères les plus impactants sur la taille finale de l'image reconstruite.

Le package est fourni avec une base d'exemple de 54 images libres de droit. Il est possible de l'utiliser avec le code suivant :

```{r eval=FALSE}
library(tipixel)
base <- file.path(find.package('tipixel'),'base') # identifier le chemin de stockage de la base
les_tuiles <- genere_base(base,redim=c(100,100),progress = "text")
les_tuiles

```

L'objet `les_tuiles` contient l'ensemble de la base d'images et constitue maintenant un tout indépendant des fichiers physiques d'image sur votre ordinateur. Il est possible de sauvegarder/réimporter cet objet R avec les fonctions classiques de R du type `save` / `load` ou `saveRDS`,`readRDS`

```{r eval=FALSE}
saveRDS(les_tuiles,"mes_tuiles.rds")
les_tuiles <- readRDS("mes_tuiles.rds")
```

Lorsque le nombre de tuiles dans la base est trop important il peut être judicieux de ne pas précharger les images, cela permet de garder de la mémoire vive disponible pour les calculs et la création de l'image finale.

Cela permet aussi de travailler avec une base d'image dont la taille dépasse la capacité de mémoire vive de la machine. Dans ce cas, le paramètre `preload` doit être passé à `FALSE` et il faut conserver les fichiers jpeg en lieu et place sur la machine. 

```{r eval=FALSE}
les_tuiles_non_charge <- genere_base(base,redim=c(100,100),preload = FALSE,progress = "text")
les_tuiles_non_charge

```




## Import de l'image cible

Il vous faut récupérer le chemin de l'image en chaîne de caractère. Sous windows, attention aux `/` et `\` R s'attend à avoir une chaîne du type `"/home/vincent/image.jpg"` et renverra un message d'erreur pour `"C:\Users\Vincent\image.jpg"`, il faudra taper `"C:\\Users\\Vincent\\image.jpg"` ou encore `"C:/Users/Vincent/image.jpg"`.

Dans l'exemple nous allons "pixeliser" une des images de la base :

```{r eval=FALSE}
img <- base::sample(x=list.files(base,full.names = TRUE),size=1) # une image au hasard
print(img)
plotraster(aperm(jpeg::readJPEG(img),c(2,1,3)))# permet d'afficher l'image en tant que graphique dans une fenêtre de plot
```



## La fonction pixel

La fonction `pixel` est la principale fonction du package. Pour l'utiliser un certain nombre de paramètres sont obligatoires : 

* `file` pointe vers l'image à pixeliser.

* `lig` et `col` définissent un quadrillage de l'image d'origine grâce à un nombre de lignes et de colonnes respectivement. Plus le maillage est fin, plus la résolution sera fine et le résultat satisfaisant, mais plus l'image `target` sera volumineuse (en dimension et en taille)

* `base` pointe vers la base

* `target` reçoit une chaîne de caractères qui spécifie le nom du fichier de sortie qui sera généré.

* `affich` affiche l'image pixelisée dans la fenêtre de plot (plus long)


```{r,eval=FALSE}

pixel(file=img,lig=5,col=5,base=les_tuiles,target='dessin.jpg',affich = TRUE)
pixel(file=img,lig=50,col=50,base=les_tuiles,target='dessin2.jpg',affich=TRUE)

```

<!-- ```{r fig.width=8, fig.height=8,echo=FALSE,eval=FALSE} -->
<!-- require(png) -->
<!-- require(grid) -->
<!-- jj<-jpeg(filename = '/mnt/docs/ThinkR/package public/tipixel/dessin2.jpg') -->
<!--  grid.raster(jpeg(filename = 'dessin2.jpg')) -->
<!-- ``` -->


Pour gagner en vitesse il faut utiliser au maximum les coeurs de votre machine, `thread` est l'argument qui correspond au nombre de thread sur lesquels paralleliser les calculs : c'est un paramètre à adapter aux capacités de la machine. _Si vous n'avez que 2 coeurs, inutile de lancer 8 thread..._ 
```{r,eval=FALSE}

pixel(file=img,lig=100,col=100,base=les_tuiles,target='dessin4.jpg' ,open=TRUE,parallel = TRUE,thread = 2)

```

Si vous utilisez une base de tuiles non préchargées, alors il faut préciser le paramètre `redim` afin de définir les dimensions des tuiles : 

```{r,eval=FALSE}

pixel(file=img,lig=50,col=50,base=les_tuiles_non_charge,target='dessin5.jpg' ,open=TRUE,parallel = TRUE,thread = 2,redim = c(20,20))

```


Le parametre `random` permet de modifier la methode de choix des tuiles. random permet de tirer au sort parmi les meilleurs tuiles, cela permet d'éviter d'avoir trop de fois les meme tuiles dans l'image finale. Pour que cela fonctionne mieux, il faut passer le parametre `doublon` à `TRUE`.

```{r eval=FALSE}

pixel(file=img,lig=100,col=100,base=les_tuiles_non_charge,target='dessin6.jpg' ,open=TRUE,parallel = TRUE,thread = 2,doublon=TRUE,random=2)

```




En cas d'insuffisance de RAM disponible vous pouvez au choix :

* Acheter de la RAM supplémentaire

* Fermer les autres programmes qui consomment de la RAM

* Supprimer de votre session R les objets en mémoire inutiles

* Diminuer le nombre de lignes/colonnes du maillage de l'image (`file`)

* Diminuer la dimension (hauteur et largeur) des tuiles

Dans une seconde version je proposerais une autre approche qui permettra de travailler sur le disque dur, ca sera plus long , mais ca marchera tant que le disque dur n'est pas plein.


